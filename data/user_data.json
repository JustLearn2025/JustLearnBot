{
  "5681066383": {
    "tests": [
      {
        "date": "2025-06-08",
        "time": "21:30",
        "test_type": "Advanced Reevaluation: Recursion",
        "topics": [
          "Recursion"
        ],
        "score": "0/4",
        "weak_topics": [
          "Recursion"
        ]
      },
      {
        "date": "2025-06-08",
        "time": "21:30",
        "test_type": "Advanced Reevaluation: Recursion",
        "topics": [
          "Recursion"
        ],
        "score": "0/4",
        "weak_topics": [
          "Recursion"
        ]
      },
      {
        "date": "2025-06-08",
        "time": "21:30",
        "test_type": "Reevaluation: Recursion",
        "topics": [
          "Recursion"
        ],
        "score": "1/3",
        "weak_topics": [
          "Recursion"
        ]
      },
      {
        "date": "2025-06-08",
        "time": "21:29",
        "test_type": "Adaptive Test",
        "score": "0/3",
        "weak_topics": [
          "Recursion"
        ],
        "needs_more_training": []
      },
      {
        "date": "2025-06-08",
        "time": "21:29",
        "test_type": "Advanced Reevaluation: Recursion",
        "topics": [
          "Recursion"
        ],
        "score": "1/4",
        "weak_topics": [
          "Recursion"
        ]
      }
    ],
    "adaptive_tests": [
      {
        "date": "2025-06-08",
        "time": "21:29",
        "test_type": "Adaptive Test",
        "topics_selected": [
          "Recursion"
        ],
        "weak_topics": [
          "Recursion"
        ],
        "passed_topics": [],
        "needs_more_training": []
      },
      {
        "date": "2025-06-08",
        "time": "20:56",
        "test_type": "Adaptive Test",
        "topics_selected": [
          "Recursion"
        ],
        "weak_topics": [],
        "passed_topics": [],
        "needs_more_training": [
          "Recursion"
        ]
      },
      {
        "date": "2025-06-08",
        "time": "16:46",
        "test_type": "Adaptive Test",
        "topics_selected": [
          "Algorithm Analysis and Big-O Notation"
        ],
        "weak_topics": [],
        "passed_topics": [],
        "needs_more_training": [
          "Big-O"
        ]
      },
      {
        "date": "2025-06-08",
        "time": "16:45",
        "test_type": "Adaptive Test",
        "topics_selected": [
          "Queues"
        ],
        "weak_topics": [],
        "passed_topics": [],
        "needs_more_training": [
          "Queues"
        ]
      },
      {
        "date": "2025-06-08",
        "time": "16:45",
        "test_type": "Adaptive Test",
        "topics_selected": [
          "Queues"
        ],
        "weak_topics": [
          "Queues"
        ],
        "passed_topics": [],
        "needs_more_training": []
      }
    ],
    "weak_topic_pool": [
      "Graphs",
      "Stacks",
      "Queues",
      "Linked Lists",
      "Recursion",
      "Big-O",
      "Arrays",
      "Trees"
    ],
    "current_test_session": null,
    "needs_more_training_pool": [],
    "ignore_before_time": {
      "reevaluation": 1749407396
    },
    "active_session_ids": {
      "reevaluation": "d94d04a3-da38-4e12-a523-100c9db1c1c0"
    }
  },
  "1353060655": {
    "tests": [
      {
        "date": "2025-06-04",
        "time": "13:15",
        "test_type": "Adaptive Test",
        "score": "0/2",
        "weak_topics": [
          "Stacks"
        ]
      }
    ],
    "adaptive_tests": [
      {
        "date": "2025-06-04",
        "time": "13:15",
        "test_type": "Adaptive Test",
        "topics_selected": [
          "Stacks"
        ],
        "weak_topics": [
          "Stacks"
        ],
        "passed_topics": []
      }
    ],
    "weak_topic_pool": [
      "Stacks"
    ],
    "current_test_session": null
  },
  "1648820635": {
    "tests": [],
    "adaptive_tests": [],
    "weak_topic_pool": [],
    "current_test_session": null
  },
  "7848133412": {
    "tests": [
      {
        "date": "2025-06-04",
        "time": "14:00",
        "test_type": "Second Exam",
        "score": "6/19",
        "weak_topics": [
          "Hashing",
          "Recursion",
          "Stacks",
          "Queues"
        ],
        "questions": [
          {
            "topic": "Hashing",
            "difficulty": "Hard",
            "question": "Which of the following is not a type of open addressing in hashing?",
            "choices": {
              "A": "Linear Probing",
              "B": "Quadratic Probing",
              "C": "Double Hashing",
              "D": "Chaining"
            },
            "correct_answer": "D",
            "explanation": "Chaining is a collision resolution technique where each bucket contains a linked list of all key-value pairs that hash to the same location. It's separate from open addressing techniques (linear probing, quadratic probing, and double hashing) which find alternative locations within the hash table itself."
          },
          {
            "topic": "Recursion",
            "difficulty": "Easy",
            "question": "Recursion requires more system memory than iteration",
            "choices": {
              "A": "True",
              "B": "False"
            },
            "correct_answer": "A",
            "explanation": "Recursive functions typically require more memory because each recursive call adds a new layer to the program stack, storing local variables and return addresses."
          },
          {
            "topic": "Stacks",
            "difficulty": "Medium",
            "question": "If the sequence of operations \u2014 push(1), push(2), pop, push(1), push(2), pop, pop, pop, push(2), pop \u2014 are performed on a stack, what is the sequence of popped out values?",
            "choices": {
              "A": "2,2,1,1,2",
              "B": "2,2,1,2,2",
              "C": "2,1,2,2,1",
              "D": "2,1,2,2,2"
            },
            "correct_answer": "A",
            "explanation": "Tracing the operations: (1) push(1) [1], (2) push(2) [1,2], (3) pop() = 2 [1], (4) push(1) [1,1], (5) push(2) [1,1,2], (6) pop() = 2 [1,1], (7) pop() = 1 [1], (8) pop() = 1 [], (9) push(2) [2], (10) pop() = 2 []. Therefore, the sequence is 2,2,1,1,2."
          },
          {
            "topic": "Stacks",
            "difficulty": "Easy",
            "question": "What happens when you try to pop from an empty stack?",
            "choices": {
              "A": "Returns null",
              "B": "Returns 0",
              "C": "Stack underflow",
              "D": "Returns the last element"
            },
            "correct_answer": "C",
            "explanation": "Attempting to pop from an empty stack causes stack underflow, which is typically handled as an error condition."
          },
          {
            "topic": "Recursion",
            "difficulty": "Medium",
            "question": "What does isPalindrome(121) return?\n\nbool isPalindrome(int n, int temp = 0) {\n    if (n == 0) return temp == 0 || temp == n;\n    return isPalindrome(n / 10, temp * 10 + n % 10);\n}",
            "choices": {
              "A": "true",
              "B": "false"
            },
            "correct_answer": "A",
            "explanation": "This function builds the reverse of n in temp.\nFor n = 121:\n- First call: n = 121, temp = 0\n- Next call: n = 12, temp = 1\n- Next call: n = 1, temp = 12\n- Last call: n = 0, temp = 121\nSince n = 0 and temp = 121, and the original n is also 121, it returns true."
          },
          {
            "topic": "Recursion",
            "difficulty": "Hard",
            "question": "What is the time complexity of the recursive Fibonacci function?",
            "choices": {
              "A": "O(n)",
              "B": "O(n\u00b2)",
              "C": "O(2\u207f)",
              "D": "O(log n)"
            },
            "correct_answer": "C",
            "explanation": "The recursive Fibonacci function makes two recursive calls for each non-base case, leading to exponential time complexity O(2\u207f)."
          },
          {
            "topic": "Stacks",
            "difficulty": "Medium",
            "question": "Consider the following scenario:\n\n(1) The five items: P, Q, R, S, and T are inserted into stack A one after another starting from T.\n(2) The stack is popped three times and each element is inserted into another stack B.\n(3) Then two elements are deleted from stack B and pushed back onto stack A.\n\nWhat are the topmost elements of stack A and stack B respectively?",
            "choices": {
              "A": "R and P",
              "B": "R and Q",
              "C": "Q and R",
              "D": "Q and P"
            },
            "correct_answer": "D",
            "explanation": "After step 1, stack A has [T, S, R, Q, P] (top to bottom). After popping three times and pushing to B, A has [T, S] and B has [P, Q, R] (top to bottom). After popping two elements from B and pushing them back to A, stack A has [T, S, R, Q] (top to bottom) and stack B has [P] (top). Therefore, the top of A is Q and the top of B is P."
          },
          {
            "topic": "Queues",
            "difficulty": "Medium",
            "question": "What is the formula to calculate the next position of queueRear in a circular queue?",
            "choices": {
              "A": "queueRear + 1",
              "B": "(queueRear + 1) % maxQueueSize",
              "C": "queueRear % maxQueueSize",
              "D": "queueRear - 1"
            },
            "correct_answer": "B",
            "explanation": "The modulo operation ensures that queueRear wraps around to 0 when it exceeds the array size."
          },
          {
            "topic": "Hashing",
            "difficulty": "Medium",
            "question": "Consider the following list: 4, 8, 20, 21, 35, 44, 49, 52, 70. Suppose we are using the binary search algorithm to find the value 3, what is the order of comparisons?",
            "choices": {
              "A": "35, 49, 70",
              "B": "35, 8, 4",
              "C": "35, 20, 4",
              "D": "35, 52, 70"
            },
            "correct_answer": "B",
            "explanation": "First comparison is with the middle element 35. Since 3 < 35, we search in the left half: 4,8,20,21. The middle element is 8. Since 3 < 8, we search in the left half: 4. Since 3 < 4, the element is not found."
          },
          {
            "topic": "Hashing",
            "difficulty": "Medium",
            "question": "Consider the following list: 4, 8, 20, 21, 35, 44, 49, 52, 70. Suppose we are using the binary search algorithm to find the value 3, what is the order of comparisons?",
            "choices": {
              "A": "35, 49, 70",
              "B": "35, 8, 4",
              "C": "35, 20, 4",
              "D": "35, 52, 70"
            },
            "correct_answer": "B",
            "explanation": "First comparison is with the middle element 35. Since 3 < 35, we search in the left half: 4,8,20,21. The middle element is 8. Since 3 < 8, we search in the left half: 4. Since 3 < 4, the element is not found."
          },
          {
            "topic": "Recursion",
            "difficulty": "Medium",
            "question": "Consider the following recursive function:\n\nint recFun(int x, int y) {\n    if (x == y) return x;\n    else if (x > y) return x + y;\n    else return recFun(x + 1, y - 1);\n}\n\nWhat is the output of executing this: cout << recFun(3, 9) << endl;",
            "choices": {
              "A": "3",
              "B": "9",
              "C": "6",
              "D": "12"
            },
            "correct_answer": "C",
            "explanation": "Starting with x = 3 and y = 9:\n- recFun(3,9) \u2192 recFun(4,8)\n- recFun(4,8) \u2192 recFun(5,7)\n- recFun(5,7) \u2192 recFun(6,6)\nAt this point, x == y, so return x, which is 6."
          },
          {
            "topic": "Queues",
            "difficulty": "Easy",
            "question": "Queue is a _________ data structure.",
            "choices": {
              "A": "First In First Out (FIFO)",
              "B": "Last In First Out (LIFO)",
              "C": "First In Last Out (FILO)",
              "D": "None of the answers is correct"
            },
            "correct_answer": "A",
            "explanation": "A queue follows the First In First Out (FIFO) principle where the first element added is the first one to be removed."
          },
          {
            "topic": "Queues",
            "difficulty": "Medium",
            "question": "In linked list implementation of queue, if only front pointer is used, which of the following operations takes worst case linear time?",
            "choices": {
              "A": "Insertion",
              "B": "Deletion",
              "C": "Retrieve front item from the queue",
              "D": "All of the above"
            },
            "correct_answer": "A",
            "explanation": "If only the front pointer is maintained, insertion requires traversing the entire list to find the end, which takes O(n) time. Deletion and retrieving the front item can be done in O(1) time since we have direct access to the front."
          },
          {
            "topic": "Hashing",
            "difficulty": "Medium",
            "question": "Consider the following list: 4, 8, 20, 21, 35, 44, 49, 52, 70. Suppose we are using the binary search algorithm to find the value 3, what is the order of comparisons?",
            "choices": {
              "A": "35, 49, 70",
              "B": "35, 8, 4",
              "C": "35, 20, 4",
              "D": "35, 52, 70"
            },
            "correct_answer": "B",
            "explanation": "First comparison is with the middle element 35. Since 3 < 35, we search in the left half: 4,8,20,21. The middle element is 8. Since 3 < 8, we search in the left half: 4. Since 3 < 4, the element is not found."
          },
          {
            "topic": "Hashing",
            "difficulty": "Hard",
            "question": "Given a hashtable that has a capacity of 8. Assuming that the hashtable uses Linear Probing to handle collisions, what array position (index) will hold the value \"41\" while adding the following numbers?\n11 24 6 33 41",
            "choices": {
              "A": "1",
              "B": "3",
              "C": "2",
              "D": "7"
            },
            "correct_answer": "C",
            "explanation": "Using h(x) = x mod 8: h(11)=3, h(24)=0, h(6)=6, h(33)=1, h(41)=1. But position 1 is already occupied by 33, so we use linear probing to find the next available slot, which is position 2."
          },
          {
            "topic": "Stacks",
            "difficulty": "Hard",
            "question": "The postfix form of the expression (A+B^D) / (E-F) + G is",
            "choices": {
              "A": "ABD^ + EF - / G+",
              "B": "ABD + ^EF - / G+",
              "C": "ABD + ^EF / - G+",
              "D": "ABD^ + EF / - G+"
            },
            "correct_answer": "A",
            "explanation": "Converting to postfix: B^D is BD^, A+B^D is ABD^+, (E-F) is EF-, (A+B^D)/(E-F) is ABD^+EF-/, and finally (A+B^D)/(E-F)+G is ABD^+EF-/G+."
          },
          {
            "topic": "Hashing",
            "difficulty": "Easy",
            "question": "What is the best time complexity and average time complexity for the linear search?",
            "choices": {
              "A": "O(n) - O(n)",
              "B": "O(log n) - O(n)",
              "C": "O(1) - O(n)",
              "D": "O(1) - O(log n)"
            },
            "correct_answer": "C",
            "explanation": "In the best case, the element is found at the first position (O(1)). In the average case, we need to search through half the elements on average (O(n))."
          },
          {
            "topic": "Queues",
            "difficulty": "Hard",
            "question": "Given an empty circular array-based queue with `maxSize = 5`, what would be the values of `queueFront` and `queueRear` (indices) after executing the following lines of code?\n\nqueue.addQueue(1);\nqueue.addQueue(2);\nqueue.deleteQueue();\nqueue.addQueue(3);\nqueue.addQueue(8);\nqueue.addQueue(9);\nqueue.deleteQueue();\nqueue.addQueue(7);\nqueue.addQueue(6);",
            "choices": {
              "A": "queueFront = 2, queueRear = 1",
              "B": "queueFront = 0, queueRear = 2",
              "C": "queueFront = 1, queueRear = 2",
              "D": "queueFront = 2, queueRear = 0"
            },
            "correct_answer": "A",
            "explanation": "Tracing the operations:\n\n- Add 1 \u2192 [1, -, -, -, -] (F=0, R=0)\n- Add 2 \u2192 [1, 2, -, -, -] (F=0, R=1)\n- Delete \u2192 [-, 2, -, -, -] (F=1, R=1)\n- Add 3 \u2192 [-, 2, 3, -, -] (F=1, R=2)\n- Add 8 \u2192 [-, 2, 3, 8, -] (F=1, R=3)\n- Add 9 \u2192 [-, 2, 3, 8, 9] (F=1, R=4)\n- Delete \u2192 [-, -, 3, 8, 9] (F=2, R=4)\n- Add 7 \u2192 [7, -, 3, 8, 9] (F=2, R=0)\n- Add 6 \u2192 [7, 6, 3, 8, 9] (F=2, R=1)\n\nThus, `queueFront = 2`, `queueRear = 1`."
          },
          {
            "topic": "Hashing",
            "difficulty": "Easy",
            "question": "What is the best time complexity and average time complexity for the linear search?",
            "choices": {
              "A": "O(n) - O(n)",
              "B": "O(log n) - O(n)",
              "C": "O(1) - O(n)",
              "D": "O(1) - O(log n)"
            },
            "correct_answer": "C",
            "explanation": "In the best case, the element is found at the first position (O(1)). In the average case, we need to search through half the elements on average (O(n))."
          }
        ],
        "correct_count": 6,
        "answers": [
          "C",
          "B",
          "C",
          "C",
          "B",
          "C",
          "C",
          "C",
          "C",
          "C",
          "C",
          "C",
          "C",
          "C",
          "C",
          "C",
          "C",
          "C",
          "C"
        ]
      },
      {
        "date": "2025-06-04",
        "time": "13:59",
        "test_type": "First Exam",
        "score": "7/20",
        "weak_topics": [
          "Big-O",
          "Linked Lists",
          "Arrays"
        ],
        "questions": [
          {
            "topic": "Linked Lists",
            "difficulty": "Hard",
            "question": "What is the output of executing the statement: recFun(first); on a linked list where first points to the sequence 5\u219210\u219215?\n\nvoid recFun(nodeType* current) {\n    if (current != NULL) {\n        cout << current->info << \" \";\n        recFun(current->link);\n        cout << current->info << \" \";\n    }\n}",
            "choices": {
              "A": "5 10 15 15 10 5",
              "B": "15 10 5 5 10 15",
              "C": "15 10 5 15 10 5",
              "D": "5 10 15 5 10 15"
            },
            "correct_answer": "A",
            "explanation": "This function prints each node's value before and after the recursive call, creating a pattern like pre-order and post-order traversal. It first prints the list in order (5, 10, 15) during the recursive descent, then again in reverse (15, 10, 5) during the recursive ascent."
          },
          {
            "topic": "Linked Lists",
            "difficulty": "Easy",
            "question": "What data structure is used to implement a linked list's nodes?",
            "choices": {
              "A": "Arrays",
              "B": "Structs or classes with data and pointer members",
              "C": "Primitive variables with references",
              "D": "Hash tables"
            },
            "correct_answer": "B",
            "explanation": "Linked list nodes are typically implemented using structs or classes that contain data fields and pointer fields (link fields) that point to the next node in the list."
          },
          {
            "topic": "Big-O",
            "difficulty": "Medium",
            "question": "What is the big-O notation for the following expression in the worst case?\\nvoid fun(){\\n if (condition){\\n    cout<<\\\"Hello\\\"<<endl;\\n }\\n else {\\n   for (i = 0; i <= N; i++){\\n     cout<<\\\"Hi\\\"<<endl;\\n   }\\n }\\n}",
            "choices": {
              "A": "O(1)",
              "B": "O(n)",
              "C": "O(n\u00b2)",
              "D": "O(log n)"
            },
            "correct_answer": "B",
            "explanation": "In the worst case, the function executes the else part which has a loop that runs N+1 times, making it O(N)."
          },
          {
            "topic": "Big-O",
            "difficulty": "Medium",
            "question": "Which of the following operations grows faster as n increases?",
            "choices": {
              "A": "5n + 100",
              "B": "n log n",
              "C": "n\u00b2/2",
              "D": "1000"
            },
            "correct_answer": "C",
            "explanation": "Among the options, n\u00b2/2 (which is O(n\u00b2)) grows faster than n log n, which grows faster than 5n + 100 (O(n)), which grows faster than 1000 (O(1))."
          },
          {
            "topic": "Big-O",
            "difficulty": "Hard",
            "question": "What is the number of operations required to execute the statement (cout << i*j << endl;) in this code?\n\nint x;\ncin >> x;\nfor (int i = 0; i < x; i++) {\n    for (int j = 0; j < x/2; j++) {\n        cout << i*j << endl;\n    }\n}",
            "choices": {
              "A": "(3/2)*(x\u00b2)",
              "B": "3*(x\u00b2)",
              "C": "(3/2)*(x\u00b2+1)",
              "D": "3*(x\u00b2+x/2)"
            },
            "correct_answer": "A",
            "explanation": "The statement is executed i\u00d7j times, where i goes from 0 to x-1 and j goes from 0 to (x/2)-1, which sums up to x\u00d7(x/2) = x\u00b2/2. Since we're counting operations, this is 3\u00d7(x\u00b2/2) = (3/2)\u00d7x\u00b2."
          },
          {
            "topic": "Big-O",
            "difficulty": "Hard",
            "question": "What is the number of times the statement executes in this code?\n\nfor (int i = 1; i <= n; i = i * 2) {\n    cout << i << endl;\n}",
            "choices": {
              "A": "n",
              "B": "log\u2082 n",
              "C": "n/2",
              "D": "2n"
            },
            "correct_answer": "B",
            "explanation": "The variable i doubles each iteration (1, 2, 4, 8, ...). This continues until i > n, which happens after approximately log\u2082 n iterations."
          },
          {
            "topic": "Big-O",
            "difficulty": "Easy",
            "question": "If F(x)= 3x\u00b2 + x\u00b3 log x, then F(x) is:",
            "choices": {
              "A": "O(x)",
              "B": "O(x\u00b3)",
              "C": "O(1)",
              "D": "O(x\u00b2)"
            },
            "correct_answer": "B",
            "explanation": "The highest order term in the expression is x\u00b3 log x, which dominates the growth rate."
          },
          {
            "topic": "Arrays",
            "difficulty": "Hard",
            "question": "In the removeAt operation for array-based lists, what is the correct order of operations?",
            "choices": {
              "A": "Shift elements, then decrease length",
              "B": "Decrease length, then shift elements",
              "C": "Only decrease length",
              "D": "Only shift elements"
            },
            "correct_answer": "A",
            "explanation": "First, elements after the removal position are shifted left to fill the gap, then the length is decreased to reflect the new size."
          },
          {
            "topic": "Big-O",
            "difficulty": "Medium",
            "question": "What is the time complexity of the following algorithm?\\nint x;\\ncin >> x;\\nfor (int i = 0; i < N; i++) {\\n    for (int j = 0; j < N/2; j++) {\\n         cout << i*j << endl;\\n     }\\n}",
            "choices": {
              "A": "O(N\u00b2)",
              "B": "O(1)",
              "C": "O(N)",
              "D": "O(2\u1d3a)"
            },
            "correct_answer": "A",
            "explanation": "The outer loop runs N times and the inner loop runs N/2 times, resulting in N\u00d7(N/2) = N\u00b2/2 which is O(N\u00b2)."
          },
          {
            "topic": "Arrays",
            "difficulty": "Easy",
            "question": "What is the main limitation of array-based lists?",
            "choices": {
              "A": "They cannot store different data types",
              "B": "They have a fixed maximum size",
              "C": "They cannot be sorted efficiently",
              "D": "They require more memory than linked lists"
            },
            "correct_answer": "B",
            "explanation": "The main limitation of array-based lists is that they have a fixed maximum size determined when the array is created. Once the list reaches this size, additional elements cannot be added without resizing the entire array."
          },
          {
            "topic": "Arrays",
            "difficulty": "Easy",
            "question": "What is the time complexity of accessing an element at a specific index in an array-based list?",
            "choices": {
              "A": "O(1)",
              "B": "O(n)",
              "C": "O(log n)",
              "D": "O(n\u00b2)"
            },
            "correct_answer": "A",
            "explanation": "Array-based lists provide direct access to elements by index, which takes constant time O(1)."
          },
          {
            "topic": "Linked Lists",
            "difficulty": "Medium",
            "question": "What does the function reversePrint print for a linked list with values 1 -> 2 -> 3 -> NULL?\n\nstruct Node {\n    int data;\n    Node* next;\n};\nvoid reversePrint(Node* head) {\n    if (head == nullptr) return;\n    reversePrint(head->next);\n    cout << head->data << \" \";\n}",
            "choices": {
              "A": "1 2 3",
              "B": "3 2 1",
              "C": "2 1 3",
              "D": "1 3 2"
            },
            "correct_answer": "B",
            "explanation": "The reversePrint function uses recursion to first traverse to the end of the list, then prints the data as it goes back up the recursion stack, effectively printing the list in reverse order."
          },
          {
            "topic": "Arrays",
            "difficulty": "Medium",
            "question": "What happens to the length variable after successfully calling removeAt() on an array-based list?",
            "choices": {
              "A": "It remains unchanged",
              "B": "It increases by 1",
              "C": "It decreases by 1",
              "D": "It is set to zero"
            },
            "correct_answer": "C",
            "explanation": "When an element is removed, the length variable is decremented by 1 to reflect the current number of elements."
          },
          {
            "topic": "Linked Lists",
            "difficulty": "Medium",
            "question": "What does the function reversePrint print for a linked list with values 1 -> 2 -> 3 -> NULL?\n\nstruct Node {\n    int data;\n    Node* next;\n};\nvoid reversePrint(Node* head) {\n    if (head == nullptr) return;\n    reversePrint(head->next);\n    cout << head->data << \" \";\n}",
            "choices": {
              "A": "1 2 3",
              "B": "3 2 1",
              "C": "2 1 3",
              "D": "1 3 2"
            },
            "correct_answer": "B",
            "explanation": "The reversePrint function uses recursion to first traverse to the end of the list, then prints the data as it goes back up the recursion stack, effectively printing the list in reverse order."
          },
          {
            "topic": "Linked Lists",
            "difficulty": "Easy",
            "question": "In a linked list node structure, what does the 'next' or 'link' field contain?",
            "choices": {
              "A": "The data of the next node",
              "B": "The address of the next node",
              "C": "The size of the next node",
              "D": "The type of the next node"
            },
            "correct_answer": "B",
            "explanation": "The 'next' or 'link' field contains the memory address (pointer) of the next node in the linked list."
          },
          {
            "topic": "Linked Lists",
            "difficulty": "Medium",
            "question": "What does the function reversePrint print for a linked list with values 1 -> 2 -> 3 -> NULL?\n\nstruct Node {\n    int data;\n    Node* next;\n};\nvoid reversePrint(Node* head) {\n    if (head == nullptr) return;\n    reversePrint(head->next);\n    cout << head->data << \" \";\n}",
            "choices": {
              "A": "1 2 3",
              "B": "3 2 1",
              "C": "2 1 3",
              "D": "1 3 2"
            },
            "correct_answer": "B",
            "explanation": "The reversePrint function uses recursion to first traverse to the end of the list, then prints the data as it goes back up the recursion stack, effectively printing the list in reverse order."
          },
          {
            "topic": "Arrays",
            "difficulty": "Medium",
            "question": "What is the time complexity of searching for an element in an unsorted array-based list?",
            "choices": {
              "A": "O(1)",
              "B": "O(n)",
              "C": "O(log n)",
              "D": "O(n\u00b2)"
            },
            "correct_answer": "B",
            "explanation": "In an unsorted array-based list, searching for an element requires examining each element one by one until the element is found or the end of the list is reached. This is sequential search with a time complexity of O(n)."
          },
          {
            "topic": "Linked Lists",
            "difficulty": "Hard",
            "question": "In a doubly linked list, when inserting a node between two existing nodes, how many pointers need to be updated?",
            "choices": {
              "A": "2",
              "B": "3",
              "C": "4",
              "D": "6"
            },
            "correct_answer": "C",
            "explanation": "Four pointers need updating: the new node's next and back pointers, the previous node's next pointer, and the next node's back pointer."
          },
          {
            "topic": "Arrays",
            "difficulty": "Hard",
            "question": "Which of the following is a correct implementation of the copy constructor for an array-based list?",
            "choices": {
              "A": "template <class Type>\narrayListType<Type>::arrayListType(const arrayListType<Type>& otherList) {\n    maxSize = otherList.maxSize;\n    length = otherList.length;\n    list = new Type[maxSize];\n    for (int i = 0; i < length; i++) {\n        list[i] = otherList.list[i];\n    }\n}",
              "B": "template <class Type>\narrayListType<Type>::arrayListType(const arrayListType<Type>& otherList) {\n    list = otherList.list;\n    length = otherList.length;\n    maxSize = otherList.maxSize;\n}",
              "C": "template <class Type>\narrayListType<Type>::arrayListType(const arrayListType<Type>& otherList) {\n    maxSize = otherList.maxSize;\n    length = 0;\n    list = new Type[maxSize];\n    for (int i = 0; i < otherList.length; i++) {\n        insertAt(i, otherList.list[i]);\n    }\n}",
              "D": "template <class Type>\narrayListType<Type>::arrayListType(const arrayListType<Type>& otherList) {\n    list = NULL;\n    *this = otherList;\n}"
            },
            "correct_answer": "A",
            "explanation": "Option A correctly implements a deep copy: it allocates new memory with the same size as the other list, copies the length and maxSize values, and then copies each element individually from the other list to the new one."
          },
          {
            "topic": "Big-O",
            "difficulty": "Easy",
            "question": "If F(n) = 10n + 5, what is its Big-O notation?",
            "choices": {
              "A": "O(1)",
              "B": "O(n)",
              "C": "O(n\u00b2)",
              "D": "O(log n)"
            },
            "correct_answer": "B",
            "explanation": "In Big-O notation, we drop constants and lower-order terms. F(n) = 10n + 5 simplifies to O(n)."
          }
        ],
        "correct_count": 7,
        "answers": [
          "A",
          "B",
          "C",
          "D",
          "A",
          "B",
          "C",
          "D",
          "A",
          "B",
          "C",
          "D",
          "A",
          "B",
          "C",
          "D",
          "A",
          "B",
          "C",
          "D"
        ]
      },
      {
        "date": "2025-06-04",
        "time": "13:58",
        "test_type": "Adaptive Test",
        "score": "0/2",
        "weak_topics": [
          "Big-O"
        ]
      }
    ],
    "adaptive_tests": [
      {
        "date": "2025-06-04",
        "time": "13:58",
        "test_type": "Adaptive Test",
        "topics_selected": [
          "Algorithm Analysis and Big-O Notation"
        ],
        "weak_topics": [
          "Big-O"
        ],
        "passed_topics": []
      }
    ],
    "weak_topic_pool": [
      "Big-O",
      "Linked Lists",
      "Arrays",
      "Hashing",
      "Recursion",
      "Stacks",
      "Queues"
    ],
    "current_test_session": null,
    "last_exam_results": {
      "date": "2025-06-04",
      "time": "14:00",
      "test_type": "Second Exam",
      "score": "6/19",
      "weak_topics": [
        "Hashing",
        "Recursion",
        "Stacks",
        "Queues"
      ],
      "questions": [
        {
          "topic": "Hashing",
          "difficulty": "Hard",
          "question": "Which of the following is not a type of open addressing in hashing?",
          "choices": {
            "A": "Linear Probing",
            "B": "Quadratic Probing",
            "C": "Double Hashing",
            "D": "Chaining"
          },
          "correct_answer": "D",
          "explanation": "Chaining is a collision resolution technique where each bucket contains a linked list of all key-value pairs that hash to the same location. It's separate from open addressing techniques (linear probing, quadratic probing, and double hashing) which find alternative locations within the hash table itself."
        },
        {
          "topic": "Recursion",
          "difficulty": "Easy",
          "question": "Recursion requires more system memory than iteration",
          "choices": {
            "A": "True",
            "B": "False"
          },
          "correct_answer": "A",
          "explanation": "Recursive functions typically require more memory because each recursive call adds a new layer to the program stack, storing local variables and return addresses."
        },
        {
          "topic": "Stacks",
          "difficulty": "Medium",
          "question": "If the sequence of operations \u2014 push(1), push(2), pop, push(1), push(2), pop, pop, pop, push(2), pop \u2014 are performed on a stack, what is the sequence of popped out values?",
          "choices": {
            "A": "2,2,1,1,2",
            "B": "2,2,1,2,2",
            "C": "2,1,2,2,1",
            "D": "2,1,2,2,2"
          },
          "correct_answer": "A",
          "explanation": "Tracing the operations: (1) push(1) [1], (2) push(2) [1,2], (3) pop() = 2 [1], (4) push(1) [1,1], (5) push(2) [1,1,2], (6) pop() = 2 [1,1], (7) pop() = 1 [1], (8) pop() = 1 [], (9) push(2) [2], (10) pop() = 2 []. Therefore, the sequence is 2,2,1,1,2."
        },
        {
          "topic": "Stacks",
          "difficulty": "Easy",
          "question": "What happens when you try to pop from an empty stack?",
          "choices": {
            "A": "Returns null",
            "B": "Returns 0",
            "C": "Stack underflow",
            "D": "Returns the last element"
          },
          "correct_answer": "C",
          "explanation": "Attempting to pop from an empty stack causes stack underflow, which is typically handled as an error condition."
        },
        {
          "topic": "Recursion",
          "difficulty": "Medium",
          "question": "What does isPalindrome(121) return?\n\nbool isPalindrome(int n, int temp = 0) {\n    if (n == 0) return temp == 0 || temp == n;\n    return isPalindrome(n / 10, temp * 10 + n % 10);\n}",
          "choices": {
            "A": "true",
            "B": "false"
          },
          "correct_answer": "A",
          "explanation": "This function builds the reverse of n in temp.\nFor n = 121:\n- First call: n = 121, temp = 0\n- Next call: n = 12, temp = 1\n- Next call: n = 1, temp = 12\n- Last call: n = 0, temp = 121\nSince n = 0 and temp = 121, and the original n is also 121, it returns true."
        },
        {
          "topic": "Recursion",
          "difficulty": "Hard",
          "question": "What is the time complexity of the recursive Fibonacci function?",
          "choices": {
            "A": "O(n)",
            "B": "O(n\u00b2)",
            "C": "O(2\u207f)",
            "D": "O(log n)"
          },
          "correct_answer": "C",
          "explanation": "The recursive Fibonacci function makes two recursive calls for each non-base case, leading to exponential time complexity O(2\u207f)."
        },
        {
          "topic": "Stacks",
          "difficulty": "Medium",
          "question": "Consider the following scenario:\n\n(1) The five items: P, Q, R, S, and T are inserted into stack A one after another starting from T.\n(2) The stack is popped three times and each element is inserted into another stack B.\n(3) Then two elements are deleted from stack B and pushed back onto stack A.\n\nWhat are the topmost elements of stack A and stack B respectively?",
          "choices": {
            "A": "R and P",
            "B": "R and Q",
            "C": "Q and R",
            "D": "Q and P"
          },
          "correct_answer": "D",
          "explanation": "After step 1, stack A has [T, S, R, Q, P] (top to bottom). After popping three times and pushing to B, A has [T, S] and B has [P, Q, R] (top to bottom). After popping two elements from B and pushing them back to A, stack A has [T, S, R, Q] (top to bottom) and stack B has [P] (top). Therefore, the top of A is Q and the top of B is P."
        },
        {
          "topic": "Queues",
          "difficulty": "Medium",
          "question": "What is the formula to calculate the next position of queueRear in a circular queue?",
          "choices": {
            "A": "queueRear + 1",
            "B": "(queueRear + 1) % maxQueueSize",
            "C": "queueRear % maxQueueSize",
            "D": "queueRear - 1"
          },
          "correct_answer": "B",
          "explanation": "The modulo operation ensures that queueRear wraps around to 0 when it exceeds the array size."
        },
        {
          "topic": "Hashing",
          "difficulty": "Medium",
          "question": "Consider the following list: 4, 8, 20, 21, 35, 44, 49, 52, 70. Suppose we are using the binary search algorithm to find the value 3, what is the order of comparisons?",
          "choices": {
            "A": "35, 49, 70",
            "B": "35, 8, 4",
            "C": "35, 20, 4",
            "D": "35, 52, 70"
          },
          "correct_answer": "B",
          "explanation": "First comparison is with the middle element 35. Since 3 < 35, we search in the left half: 4,8,20,21. The middle element is 8. Since 3 < 8, we search in the left half: 4. Since 3 < 4, the element is not found."
        },
        {
          "topic": "Hashing",
          "difficulty": "Medium",
          "question": "Consider the following list: 4, 8, 20, 21, 35, 44, 49, 52, 70. Suppose we are using the binary search algorithm to find the value 3, what is the order of comparisons?",
          "choices": {
            "A": "35, 49, 70",
            "B": "35, 8, 4",
            "C": "35, 20, 4",
            "D": "35, 52, 70"
          },
          "correct_answer": "B",
          "explanation": "First comparison is with the middle element 35. Since 3 < 35, we search in the left half: 4,8,20,21. The middle element is 8. Since 3 < 8, we search in the left half: 4. Since 3 < 4, the element is not found."
        },
        {
          "topic": "Recursion",
          "difficulty": "Medium",
          "question": "Consider the following recursive function:\n\nint recFun(int x, int y) {\n    if (x == y) return x;\n    else if (x > y) return x + y;\n    else return recFun(x + 1, y - 1);\n}\n\nWhat is the output of executing this: cout << recFun(3, 9) << endl;",
          "choices": {
            "A": "3",
            "B": "9",
            "C": "6",
            "D": "12"
          },
          "correct_answer": "C",
          "explanation": "Starting with x = 3 and y = 9:\n- recFun(3,9) \u2192 recFun(4,8)\n- recFun(4,8) \u2192 recFun(5,7)\n- recFun(5,7) \u2192 recFun(6,6)\nAt this point, x == y, so return x, which is 6."
        },
        {
          "topic": "Queues",
          "difficulty": "Easy",
          "question": "Queue is a _________ data structure.",
          "choices": {
            "A": "First In First Out (FIFO)",
            "B": "Last In First Out (LIFO)",
            "C": "First In Last Out (FILO)",
            "D": "None of the answers is correct"
          },
          "correct_answer": "A",
          "explanation": "A queue follows the First In First Out (FIFO) principle where the first element added is the first one to be removed."
        },
        {
          "topic": "Queues",
          "difficulty": "Medium",
          "question": "In linked list implementation of queue, if only front pointer is used, which of the following operations takes worst case linear time?",
          "choices": {
            "A": "Insertion",
            "B": "Deletion",
            "C": "Retrieve front item from the queue",
            "D": "All of the above"
          },
          "correct_answer": "A",
          "explanation": "If only the front pointer is maintained, insertion requires traversing the entire list to find the end, which takes O(n) time. Deletion and retrieving the front item can be done in O(1) time since we have direct access to the front."
        },
        {
          "topic": "Hashing",
          "difficulty": "Medium",
          "question": "Consider the following list: 4, 8, 20, 21, 35, 44, 49, 52, 70. Suppose we are using the binary search algorithm to find the value 3, what is the order of comparisons?",
          "choices": {
            "A": "35, 49, 70",
            "B": "35, 8, 4",
            "C": "35, 20, 4",
            "D": "35, 52, 70"
          },
          "correct_answer": "B",
          "explanation": "First comparison is with the middle element 35. Since 3 < 35, we search in the left half: 4,8,20,21. The middle element is 8. Since 3 < 8, we search in the left half: 4. Since 3 < 4, the element is not found."
        },
        {
          "topic": "Hashing",
          "difficulty": "Hard",
          "question": "Given a hashtable that has a capacity of 8. Assuming that the hashtable uses Linear Probing to handle collisions, what array position (index) will hold the value \"41\" while adding the following numbers?\n11 24 6 33 41",
          "choices": {
            "A": "1",
            "B": "3",
            "C": "2",
            "D": "7"
          },
          "correct_answer": "C",
          "explanation": "Using h(x) = x mod 8: h(11)=3, h(24)=0, h(6)=6, h(33)=1, h(41)=1. But position 1 is already occupied by 33, so we use linear probing to find the next available slot, which is position 2."
        },
        {
          "topic": "Stacks",
          "difficulty": "Hard",
          "question": "The postfix form of the expression (A+B^D) / (E-F) + G is",
          "choices": {
            "A": "ABD^ + EF - / G+",
            "B": "ABD + ^EF - / G+",
            "C": "ABD + ^EF / - G+",
            "D": "ABD^ + EF / - G+"
          },
          "correct_answer": "A",
          "explanation": "Converting to postfix: B^D is BD^, A+B^D is ABD^+, (E-F) is EF-, (A+B^D)/(E-F) is ABD^+EF-/, and finally (A+B^D)/(E-F)+G is ABD^+EF-/G+."
        },
        {
          "topic": "Hashing",
          "difficulty": "Easy",
          "question": "What is the best time complexity and average time complexity for the linear search?",
          "choices": {
            "A": "O(n) - O(n)",
            "B": "O(log n) - O(n)",
            "C": "O(1) - O(n)",
            "D": "O(1) - O(log n)"
          },
          "correct_answer": "C",
          "explanation": "In the best case, the element is found at the first position (O(1)). In the average case, we need to search through half the elements on average (O(n))."
        },
        {
          "topic": "Queues",
          "difficulty": "Hard",
          "question": "Given an empty circular array-based queue with `maxSize = 5`, what would be the values of `queueFront` and `queueRear` (indices) after executing the following lines of code?\n\nqueue.addQueue(1);\nqueue.addQueue(2);\nqueue.deleteQueue();\nqueue.addQueue(3);\nqueue.addQueue(8);\nqueue.addQueue(9);\nqueue.deleteQueue();\nqueue.addQueue(7);\nqueue.addQueue(6);",
          "choices": {
            "A": "queueFront = 2, queueRear = 1",
            "B": "queueFront = 0, queueRear = 2",
            "C": "queueFront = 1, queueRear = 2",
            "D": "queueFront = 2, queueRear = 0"
          },
          "correct_answer": "A",
          "explanation": "Tracing the operations:\n\n- Add 1 \u2192 [1, -, -, -, -] (F=0, R=0)\n- Add 2 \u2192 [1, 2, -, -, -] (F=0, R=1)\n- Delete \u2192 [-, 2, -, -, -] (F=1, R=1)\n- Add 3 \u2192 [-, 2, 3, -, -] (F=1, R=2)\n- Add 8 \u2192 [-, 2, 3, 8, -] (F=1, R=3)\n- Add 9 \u2192 [-, 2, 3, 8, 9] (F=1, R=4)\n- Delete \u2192 [-, -, 3, 8, 9] (F=2, R=4)\n- Add 7 \u2192 [7, -, 3, 8, 9] (F=2, R=0)\n- Add 6 \u2192 [7, 6, 3, 8, 9] (F=2, R=1)\n\nThus, `queueFront = 2`, `queueRear = 1`."
        },
        {
          "topic": "Hashing",
          "difficulty": "Easy",
          "question": "What is the best time complexity and average time complexity for the linear search?",
          "choices": {
            "A": "O(n) - O(n)",
            "B": "O(log n) - O(n)",
            "C": "O(1) - O(n)",
            "D": "O(1) - O(log n)"
          },
          "correct_answer": "C",
          "explanation": "In the best case, the element is found at the first position (O(1)). In the average case, we need to search through half the elements on average (O(n))."
        }
      ],
      "correct_count": 6,
      "answers": [
        "C",
        "B",
        "C",
        "C",
        "B",
        "C",
        "C",
        "C",
        "C",
        "C",
        "C",
        "C",
        "C",
        "C",
        "C",
        "C",
        "C",
        "C",
        "C"
      ]
    }
  },
  "2074759812": {
    "tests": [],
    "adaptive_tests": [],
    "weak_topic_pool": [],
    "current_test_session": {
      "test_type": "Adaptive Test",
      "start_time": "2025-06-04 14:00:20",
      "topics": [
        "Sorting Algorithms"
      ],
      "remaining_topics": [
        "Sorting Algorithms"
      ],
      "current_topic_index": 0,
      "current_question": {
        "topic": "Sorting",
        "difficulty": "Easy",
        "question": "What is the best-case time complexity of insertion sort?",
        "choices": {
          "A": "O(n\u00b2)",
          "B": "O(n)",
          "C": "O(n log n)",
          "D": "O(1)"
        },
        "correct_answer": "B",
        "explanation": "The best case for insertion sort is when the array is already sorted, requiring only one pass with no shifts."
      },
      "completed_topics": [],
      "weak_topics": [],
      "passed_topics": [],
      "answers": [
        {
          "topic": "Sorting",
          "difficulty": "Medium",
          "correct": false,
          "timestamp": "2025-06-04 14:00:28"
        },
        {
          "topic": "Sorting",
          "difficulty": "Easy",
          "correct": true,
          "timestamp": "2025-06-04 14:00:38"
        },
        {
          "topic": "Sorting",
          "difficulty": "Hard",
          "correct": false,
          "timestamp": "2025-06-04 14:00:57"
        },
        {
          "topic": "Sorting",
          "difficulty": "Medium",
          "correct": false,
          "timestamp": "2025-06-04 14:01:02"
        }
      ],
      "questions_asked": {
        "Sorting": {
          "Easy": [
            "What is the complexity of selection sorting?"
          ],
          "Medium": [
            "In merge sort, what is the key operation in the co",
            "In terms of swaps, how does Selection Sort compare"
          ],
          "Hard": [
            "For selection sort, what is the number of swaps in"
          ]
        }
      },
      "topic_question_count": {
        "Sorting": 4
      }
    }
  },
  "1119443796": {
    "tests": [],
    "adaptive_tests": [],
    "weak_topic_pool": [],
    "current_test_session": null
  }
}